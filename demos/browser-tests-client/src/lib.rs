#![cfg(target_arch = "wasm32")]

//! WASM harness that exposes the macro-generated `BrowserDemoClient` to JavaScript.
//!
//! The Playwright suite loads this module, connects to the WebSocket server, and
//! drives unary + streaming RPCs through the same `BrowserDemo` trait that backs
//! the native demos. There is intentionally very little handwritten RPC glue here
//! â€” the goal is to exercise the code generated by `#[rapace::service]` end to end.

use std::sync::Arc;

use futures::StreamExt;
use rapace::AnyTransport;
use rapace::RpcSession;
use rapace::WebSocketTransport;
use rapace::rapace_core::{RpcError, TransportError};
use rapace_browser_tests_proto::{
    BrowserDemoClient, CountEvent, NumbersRequest, NumbersSummary, PhraseRequest, PhraseResponse,
};
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::spawn_local;
use web_sys::console;

/// High-level wrapper that JavaScript calls into.
#[wasm_bindgen]
pub struct BrowserDemoHarness {
    client: BrowserDemoClient,
    session: Arc<RpcSession>,
}

#[wasm_bindgen]
impl BrowserDemoHarness {
    /// Connect to the BrowserDemo server over WebSocket.
    #[wasm_bindgen(js_name = connect)]
    pub async fn connect(url: String) -> Result<BrowserDemoHarness, JsValue> {
        console_error_panic_hook::set_once();

        let ws_transport = WebSocketTransport::connect(&url)
            .await
            .map_err(transport_err)?;
        let transport = AnyTransport::new(ws_transport);
        let session = Arc::new(RpcSession::with_channel_start(transport, 2));

        // Keep the session pump alive.
        let session_for_task = session.clone();
        spawn_local(async move {
            if let Err(err) = session_for_task.run().await {
                console::error_1(&JsValue::from_str(&format!(
                    "RpcSession terminated: {err:?}"
                )));
            }
        });

        let client = BrowserDemoClient::new(session.clone());

        Ok(BrowserDemoHarness { client, session })
    }

    /// Call the unary summarize_numbers RPC.
    #[wasm_bindgen(js_name = summarizeNumbers)]
    pub async fn summarize_numbers(&self, values: js_sys::Array) -> Result<JsValue, JsValue> {
        let parsed = values
            .iter()
            .map(|value| {
                value
                    .as_f64()
                    .map(|f| f as i32)
                    .ok_or_else(|| JsValue::from_str("values must be numbers"))
            })
            .collect::<Result<Vec<i32>, JsValue>>()?;

        let request = NumbersRequest { values: parsed };
        let summary = self
            .client
            .summarize_numbers(request)
            .await
            .map_err(rpc_err)?;

        Ok(numbers_summary_to_js(&summary))
    }

    /// Call the unary transform_phrase RPC.
    #[wasm_bindgen(js_name = transformPhrase)]
    pub async fn transform_phrase(&self, phrase: String, shout: bool) -> Result<JsValue, JsValue> {
        let request = PhraseRequest { phrase, shout };
        let response = self
            .client
            .transform_phrase(request)
            .await
            .map_err(rpc_err)?;

        Ok(phrase_response_to_js(&response))
    }

    /// Execute the server-streaming countdown RPC and return every emitted event as a JS array.
    #[wasm_bindgen]
    pub async fn countdown(&self, start: u32) -> Result<JsValue, JsValue> {
        let mut stream = self.client.countdown(start).await.map_err(rpc_err)?;
        let items = js_sys::Array::new();

        while let Some(next) = stream.next().await {
            let event = next.map_err(rpc_err)?;
            items.push(&count_event_to_js(&event));
        }

        Ok(items.into())
    }

    /// Close the underlying WebSocket transport.
    pub fn disconnect(&self) {
        self.session.transport().close();
    }
}

fn numbers_summary_to_js(summary: &NumbersSummary) -> JsValue {
    let obj = js_sys::Object::new();
    let _ = js_sys::Reflect::set(&obj, &"sum".into(), &JsValue::from(summary.sum));
    let _ = js_sys::Reflect::set(&obj, &"mean".into(), &JsValue::from(summary.mean));
    let _ = js_sys::Reflect::set(&obj, &"min".into(), &JsValue::from(summary.min));
    let _ = js_sys::Reflect::set(&obj, &"max".into(), &JsValue::from(summary.max));
    obj.into()
}

fn phrase_response_to_js(response: &PhraseResponse) -> JsValue {
    let obj = js_sys::Object::new();
    let _ = js_sys::Reflect::set(&obj, &"title".into(), &JsValue::from_str(&response.title));
    let _ = js_sys::Reflect::set(
        &obj,
        &"original_len".into(),
        &JsValue::from(response.original_len),
    );
    obj.into()
}

fn count_event_to_js(event: &CountEvent) -> JsValue {
    let obj = js_sys::Object::new();
    let _ = js_sys::Reflect::set(&obj, &"value".into(), &JsValue::from(event.value));
    let _ = js_sys::Reflect::set(&obj, &"remaining".into(), &JsValue::from(event.remaining));
    obj.into()
}

fn rpc_err(err: RpcError) -> JsValue {
    JsValue::from_str(&format!("rpc error: {err}"))
}

fn transport_err(err: TransportError) -> JsValue {
    JsValue::from_str(&format!("transport error: {err}"))
}
