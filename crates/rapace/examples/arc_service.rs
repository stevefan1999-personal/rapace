//! Example demonstrating Arc<T> service implementation pattern.
//!
//! This example shows how to use Arc<T> with rapace services,
//! which is essential when:
//! - The service trait is in a separate crate (e.g., -proto crate)
//! - You need to share service state across multiple connection handlers
//! - The service needs to be Clone for spawning into tasks
//!
//! Run with: `cargo run --example arc_service -p rapace`

use std::sync::Arc;

use rapace_core::RpcSession;

// Simulating a -proto crate: service trait definition
mod counter_proto {

    /// Counter service that tracks how many times it's been called.
    ///
    /// This trait would typically live in a separate `-proto` crate,
    /// allowing client and server implementations to depend on it without
    /// coupling to each other's implementation details.
    #[allow(async_fn_in_trait)]
    #[rapace::service]
    pub trait Counter {
        /// Increment the counter and return the new value.
        async fn increment(&self) -> u32;

        /// Get the current counter value without incrementing.
        async fn get(&self) -> u32;
    }
}

// Simulating an -impl crate: service implementation
mod counter_impl {
    use super::counter_proto::Counter;
    use std::sync::atomic::{AtomicU32, Ordering};

    /// Implementation of the Counter service.
    ///
    /// This struct would typically live in a separate implementation crate.
    /// It needs to be wrapped in Arc to:
    /// 1. Share state across multiple RPC handlers
    /// 2. Implement Clone (via Arc::clone) for spawning into tasks
    /// 3. Avoid orphan rule violations when implementing the trait
    pub struct CounterService {
        pub count: AtomicU32,
    }

    impl CounterService {
        pub fn new() -> Self {
            Self {
                count: AtomicU32::new(0),
            }
        }
    }

    // Implement the trait on the concrete type
    impl Counter for CounterService {
        async fn increment(&self) -> u32 {
            self.count.fetch_add(1, Ordering::SeqCst) + 1
        }

        async fn get(&self) -> u32 {
            self.count.load(Ordering::SeqCst)
        }
    }

    // Thanks to the blanket impl generated by #[rapace::service],
    // Arc<CounterService> automatically implements Counter!
    // This is what solves the orphan rule issue described in #58.
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let rt = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap();
    rt.block_on(async_main())
}

async fn async_main() -> Result<(), Box<dyn std::error::Error>> {
    use counter_impl::CounterService;
    use counter_proto::{CounterClient, CounterServer};

    println!("=== Arc<T> Service Pattern Demo ===\n");

    // Create an in-memory transport pair
    let (client_transport, server_transport) = rapace::Transport::mem_pair();

    // Create the service implementation
    let service = CounterService::new();

    // Wrap in Arc - this is the key pattern!
    // Arc<CounterService> implements Counter thanks to the blanket impl.
    let service_arc = Arc::new(service);

    // We can clone the Arc to share across multiple handlers
    let metrics_handle = Arc::clone(&service_arc);

    // Spawn a background task that could use the same service instance
    tokio::spawn(async move {
        use counter_proto::Counter; // Need trait in scope to call methods
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        let count = metrics_handle.get().await;
        println!(
            "[Background task] Current count from shared instance: {}",
            count
        );
    });

    // Create and spawn the server using the Arc'd service
    // The blanket impl allows us to pass Arc<CounterService> directly
    let server = CounterServer::new(service_arc);
    let server_handle = tokio::spawn(server.serve(server_transport));

    // Create client session and spawn demux loop
    let session = Arc::new(RpcSession::new(client_transport.clone()));
    let session_clone = session.clone();
    tokio::spawn(async move {
        if let Err(e) = session_clone.run().await {
            eprintln!("Session error: {}", e);
        }
    });

    // Create the client
    let client = CounterClient::new(session);

    // Make some RPC calls
    println!("Calling increment()...");
    let val1 = client.increment().await?;
    println!("  Result: {}\n", val1);

    println!("Calling increment() again...");
    let val2 = client.increment().await?;
    println!("  Result: {}\n", val2);

    println!("Calling get()...");
    let current = client.get().await?;
    println!("  Result: {}\n", current);

    // Give background task time to run
    tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;

    println!("\n=== Demo Complete ===");
    println!("\nKey takeaway:");
    println!("  Arc<CounterService> implements Counter thanks to the blanket impl:");
    println!("  impl<T: Counter> Counter for Arc<T> {{ ... }}");
    println!("\nThis solves issue #58 by allowing you to:");
    println!("  1. Define the trait in a -proto crate");
    println!("  2. Implement it on your concrete type in an -impl crate");
    println!("  3. Use Arc<YourType> without orphan rule violations");

    // Cleanup
    client_transport.close();
    server_handle.abort();

    Ok(())
}
