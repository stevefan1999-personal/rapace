//! Test that demonstrates Arc<T> implementing the service trait.
//!
//! This test validates the fix for issue #58, where implementing a service trait
//! on Arc<T> would fail due to orphan rules when the trait is in a separate crate.
//!
//! The blanket impl `impl<T: ServiceTrait> ServiceTrait for Arc<T>` generated by
//! the macro allows users to:
//! 1. Implement the trait on their concrete type T
//! 2. Use Arc<T> directly as a service implementation
//! 3. Share the service across multiple connection handlers (Clone via Arc::clone)

use std::sync::Arc;

use rapace_core::RpcSession;

// Simulating a -proto crate: trait definition lives here
mod proto {
    use rapace::prelude::*;

    #[allow(async_fn_in_trait)]
    #[rapace::service]
    pub trait FooService {
        async fn bar(&self) -> String;
        async fn count(&self, n: u32) -> Streaming<u32>;
    }
}

// Simulating an -impl crate: implementation lives here
mod implementation {
    use rapace::prelude::*;
    use std::sync::atomic::{AtomicU32, Ordering};

    pub struct FooImpl {
        pub call_count: AtomicU32,
    }

    impl super::proto::FooService for FooImpl {
        async fn bar(&self) -> String {
            let count = self.call_count.fetch_add(1, Ordering::SeqCst);
            format!("bar called {} times", count + 1)
        }

        async fn count(&self, n: u32) -> Streaming<u32> {
            let (tx, rx) = tokio::sync::mpsc::channel(16);

            tokio::spawn(async move {
                for i in 0..n {
                    if tx.send(Ok(i)).await.is_err() {
                        break;
                    }
                }
            });

            Box::pin(tokio_stream::wrappers::ReceiverStream::new(rx))
        }
    }
}

#[tokio_test_lite::test]
async fn test_arc_impl_orphan_rule_fix() -> Result<(), Box<dyn std::error::Error>> {
    use implementation::FooImpl;
    use proto::{FooServiceClient, FooServiceServer};

    // Create an in-memory transport pair
    let (client_transport, server_transport) = rapace::Transport::mem_pair();

    // Create the concrete implementation
    let foo_impl = FooImpl {
        call_count: std::sync::atomic::AtomicU32::new(0),
    };

    // Wrap in Arc - this is the key test!
    // Before the fix, this would fail to compile due to orphan rules
    // when FooService is in a different crate than Arc or FooImpl.
    let foo_arc = Arc::new(foo_impl);

    // The blanket impl allows Arc<FooImpl> to be used directly as the service
    let server = FooServiceServer::new(foo_arc);
    let server_handle = tokio::spawn(server.serve(server_transport));

    // Create client session and spawn demux loop
    let session = Arc::new(RpcSession::new(client_transport.clone()));
    let session_clone = session.clone();
    tokio::spawn(async move {
        let _ = session_clone.run().await;
    });
    let client = FooServiceClient::new(session);

    // Test unary RPC
    let result1 = client.bar().await?;
    assert_eq!(result1, "bar called 1 times");

    let result2 = client.bar().await?;
    assert_eq!(result2, "bar called 2 times");

    // Test streaming RPC
    use tokio_stream::StreamExt;
    let mut stream = client.count(5).await?;
    let mut collected = Vec::new();
    while let Some(item) = stream.next().await {
        collected.push(item?);
    }
    assert_eq!(collected, vec![0, 1, 2, 3, 4]);

    // Cleanup
    client_transport.close();
    server_handle.abort();

    Ok(())
}

#[tokio_test_lite::test]
async fn test_arc_clone_sharing() -> Result<(), Box<dyn std::error::Error>> {
    use implementation::FooImpl;
    use proto::{FooServiceClient, FooServiceServer};

    // This test demonstrates the use case: Arc allows sharing the service
    // across multiple connection handlers or tasks

    let (client_transport, server_transport) = rapace::Transport::mem_pair();

    let foo_impl = Arc::new(FooImpl {
        call_count: std::sync::atomic::AtomicU32::new(0),
    });

    // We can clone the Arc and use it in multiple places
    let foo_clone1 = Arc::clone(&foo_impl);
    let foo_clone2 = Arc::clone(&foo_impl);

    // All clones implement the trait via the blanket impl
    let server = FooServiceServer::new(foo_clone1);
    let server_handle = tokio::spawn(server.serve(server_transport));

    // We could use foo_clone2 elsewhere (e.g., another server, metrics, etc.)
    assert_eq!(Arc::strong_count(&foo_impl), 3); // original + clone1 + clone2

    // Create client session and spawn demux loop
    let session = Arc::new(RpcSession::new(client_transport.clone()));
    let session_clone = session.clone();
    tokio::spawn(async move {
        let _ = session_clone.run().await;
    });
    let client = FooServiceClient::new(session);

    let result = client.bar().await?;
    assert_eq!(result, "bar called 1 times");

    // The call count is shared across all Arc clones
    drop(foo_clone2);
    assert_eq!(Arc::strong_count(&foo_impl), 2);

    // Cleanup
    client_transport.close();
    server_handle.abort();

    Ok(())
}
